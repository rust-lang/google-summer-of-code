# Google Summer of Code 2025
This page contains information about the `19` projects that were
[accepted](https://blog.rust-lang.org/2025/05/08/gsoc-2025-selected-projects.html)
into [Google Summer of Code 2025](https://summerofcode.withgoogle.com/programs/2025/projects)
under the Rust Project organization.

Google Summer of Code 2025 is currently in progress, it is expected to conclude in Autumn 2025. After that we will post the results
on the Rust blog and also here.

## Index

*Note that the projects are displayed in alphabetical order.*

- [ABI/Layout handling for the automatic differentiation feature](#abilayout-handling-for-the-automatic-differentiation-feature)
- [Add safety contracts](#add-safety-contracts)
- [Bootstrap of rustc with `rustc_codegen_gcc`](#bootstrap-of-rustc-with-rustc_codegen_gcc)
- [Cargo: Build script delegation](#cargo-build-script-delegation)
- [Distributed and resource-efficient verification](#distributed-and-resource-efficient-verification)
- [Enable Witness Generation in `cargo-semver-checks`](#enable-witness-generation-in-cargo-semver-checks)
- [Extend behavioural testing of `std::arch` intrinsics](#extend-behavioural-testing-of-stdarch-intrinsics)
- [Implement merge functionality in bors](#implement-merge-functionality-in-bors)
- [Improve bootstrap](#improve-bootstrap)
- [Improve Wild linker test suites](#improve-wild-linker-test-suites)
- [Improving the Rustc Parallel Frontend: Parallel Macro Expansion](#improving-the-rustc-parallel-frontend-parallel-macro-expansion)
- [Make `cargo-semver-checks` faster](#make-cargo-semver-checks-faster)
- [Make Rustup Concurrent](#make-rustup-concurrent)
- [Mapping the Maze of Rust's UI Test Suite with Established Continuous Integration Practices](#mapping-the-maze-of-rusts-ui-test-suite-with-established-continuous-integration-practices)
- [Modernising the libc Crate](#modernising-the-libc-crate)
- [New proc-macro Server API for Rust-Analyzer](#new-proc-macro-server-api-for-rust-analyzer)
- [Prepare `stable_mir` crate for publishing](#prepare-stable_mir-crate-for-publishing)
- [Prototype an alternative architecture for `cargo fix` using `cargo check`](#prototype-an-alternative-architecture-for-cargo-fix-using-cargo-check)
- [Prototype Cargo Plumbing Commands](#prototype-cargo-plumbing-commands)

## Projects

### ABI/Layout handling for the automatic differentiation feature

This project is being implemented by [Marcelo Domínguez](https://github.com/sa4dus).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/USQvru7i)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20ABI.2FLayout.20handling.20for.20autodiff/with/516963958)

**Description**

Over the last year, support for automatic differentiation ('autodiff') was added to the Rust compiler. The autodiff tool which we are using ([Enzyme](https://enzyme.mit.edu/)) operates
on LLVM-IR, which is the intermediate representation of code, used by LLVM. LLVM is the default backend of the Rust compiler. Unfortunately, two layout related problems limit its usability.

A) The Rust compiler has a set of ABI optimizations which can improve performance, but make it harder for autodiff to work. An example is the function `fn foo(a: f32, b: f32) -> f32`,
which the compiler might optimize to `fn foo(x: i64) -> f32`. While this is fine from an LLVM perspective, it makes it hard for Enzyme, the LLVM based autodiff tool.
More information about such optimizations can be found [here](https://rust-lang.zulipchat.com/#narrow/channel/182449-t-compiler.2Fhelp/topic/.E2.9C.94.20Where.20do.20ABI.20.22changes.22.20happen.3F).
If a function has a `#[rustc_autodiff]` attribute, the Rust compiler should simply not perform such optimizations. We don't want to disable these optimizations for all functions, as they are generally beneficial.
Multiple examples of function headers which will get handled incorrectly at the moment are listed [here](https://github.com/EnzymeAD/rust/issues/105).

B) Enzyme requires good information about the memory layout of types, both to be able to differentiate the code, and to do so efficiently. In order to help Enzyme,
we want to lower more Type Information from MIR or even THIR into LLVM-IR metadata, or make better usage of existing debug info. If you are interested in this part and
also have some LLVM experience, please have a look at the LLVM website for the related proposal.

For both A) and B), the online compiler explorer [here](https://enzyme.mit.edu/explorer/) can be used to trigger both types of bugs, to get a feeling for existing problems.

**Expected result**

The Rust compiler should not perform ABI optimizations on functions with the `#[rustc_autodiff]` attribute. As a result, `#[autodiff(..)]` should be able to handle functions with almost arbitrary headers. If a general solution turns out tricky, it is ok to focus on the most common types like those listed in the issue above (e.g. combinations of floats, small arrays/structs/tuples, etc.). We care less about advanced types like those listed [here](https://doc.rust-lang.org/reference/special-types-and-traits.html). These changes can't have a performance impact on functions without the `#[rustc_autodiff]` attribute.

Newly working testcases should be added to the rust test suite. The `rustc_autodiff` parsing in the [autodiff frontend](https://github.com/rust-lang/rust/pull/129458) might need small bugfixes if the new testcases discover additional bugs, but those can also be solved by other contributors.

Examples for code that currently is not handled correctly can be discussed in the project proposal phase.

**Project size**

Medium.

**Mentors**
- Manuel Drehwald ([GitHub](https://github.com/zusez4), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/348574-Manuel-Drehwald))
- Oli ([GitHub](https://github.com/oli-obk), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/124288-oli))

**Related links**
- [Automatic differentiation working group](https://rust-lang.zulipchat.com/#narrow/channel/390790-wg-autodiff)

### Add safety contracts

This project is being implemented by [Dawid Lachowicz](https://github.com/dawidl022).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/UYWEKUkd)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Add.20safety.20contracts/with/516964153)

**Description**

There is a Rust project goal to
[instrument the Rust standard library with safety contracts](https://rust-lang.github.io/rust-project-goals/2025h1/std-contracts.html).
With this approach we are moving from informal comments specifying safety requirements on `unsafe` functions to executable Rust code. To prioritize which functions to equip with contracts first, we run a verification contest in the
[verify-rust-std](https://github.com/model-checking/verify-rust-std) fork. In this contest, [challenges](https://model-checking.github.io/verify-rust-std/challenges.html)
have been put up that request specific sets of functions to be equipped with
contracts. We also welcome new challenges being proposed by anyone, or contracts being
contributed outside any of the existing challenges.

For example, we are currently looking for contributions towards the following challenges:
- [Verify the memory safety of core intrinsics using raw pointers](https://model-checking.github.io/verify-rust-std/challenges/0002-intrinsics-memory.html)
- [Memory safety of BTreeMap's `btree::node` module](https://model-checking.github.io/verify-rust-std/challenges/0004-btree-node.html)
- [Safety of Methods for Atomic Types & Atomic Intrinsics](https://model-checking.github.io/verify-rust-std/challenges/0007-atomic-types.html)
- [Contracts for SmallSort](https://model-checking.github.io/verify-rust-std/challenges/0008-smallsort.html)
- [Safety of `NonZero`](https://model-checking.github.io/verify-rust-std/challenges/0012-nonzero.html)

There is, however, no restriction to contribute to just those challenges: any of
the other open challenges are equally of interest, and so is creating new
challenges.

**Expected result**

A set of safety contracts and harnesses have been implemented in
[verify-rust-std](https://github.com/model-checking/verify-rust-std) for one of
the open challenges or any newly created challenge.
A stretch goal is to port upstream as many of those contracts as possible.

**Project size**

Large.

**Mentor**
- Michael Tautschnig ([GitHub](https://github.com/tautschnig), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/887765-Michael-Tautschnig))

### Bootstrap of rustc with `rustc_codegen_gcc`

This project is being implemented by [Michał Kostrubiec](https://github.com/FractalFir).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/KmfCY0i6)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Bootstrap.20of.20rustc.20with.20rustc_codegen_gcc/with/516964245)

**Description**

[`rustc_codegen_gcc`](https://github.com/rust-lang/rustc_codegen_gcc) [used to be able to compile `rustc`](https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-10) and use the resulting compiler to successfully compile a `Hello, World!` program.
While it can still compile a [stage 2](https://rustc-dev-guide.rust-lang.org/building/bootstrapping/what-bootstrapping-does.html#stage-2-the-truly-current-compiler) `rustc`, the resulting compiler cannot compile the standard library anymore.

The goal of this project would be to fix in `rustc_codegen_gcc` any issue preventing the resulting compiler to compile a `Hello, World!` program and the standard library.
Those issues are not known, so the participant would need to attempt to do a bootstrap and investigate the issues that arises.

If time allows, an optional additional goal could be to be able to do a full bootstrap of `rustc` with `rustc_codegen_gcc`, meaning fixing even more issues to achieve this result.

**Expected result**

A `rustc_codegen_gcc` that can compile a stage 2 `rustc` where the resulting compiler can compile a `Hello, World!` program using the standard library (also compiled by that resulting compiler).

An optional additional goal would be: a `rustc_codegen_gcc` that can do a full bootstrap of the Rust compiler. This means getting a stage 3 `rustc` that is identical to stage 2.

**Project size**

Large.

**Mentor**
- Antoni Boucher ([GitHub](https://github.com/antoyo), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/404242-antoyo))

**Related links**
- [rustc_codegen_gcc](https://rust-lang.zulipchat.com/#narrow/channel/386786-rustc-codegen-gcc/)

### Cargo: Build script delegation

This project is being implemented by [Naman Garg](https://github.com/namanlp).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/nUt4PdAA)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Cargo.3A.20Build.20script.20delegation/with/516964379)

**Description**

When developers need to extend how Cargo builds their package,
they can write a [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html).
This gives users quite a bit of flexibility but
- Allows running arbitrary code on the users system, requiring extra auditing
- Needs to be compiled and run before the relevant package can be built
- They are all-or-nothing, requiring users to do extra checks to avoid running expensive logic
- They run counter to the principles of third-party build tools that try to mimic Cargo

A developer could make their build script a thin wrapper around a library
(e.g. [shadow-rs](https://crates.io/crates/shadow-rs))
but a build script still exists to be audited (even if its small) and each individual wrapper build script must be compiled and linked.
This is still opaque to third-party build tools.

Leveraging an unstable feature,
[artifact dependencies](https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#artifact-dependencies),
we could allow a developer to say that one or more dependencies should be run as build scripts, passing parameters to them.

This project would add unstable support for build script delegation that can
then be evaluated for proposing as an RFC for approval.

See [the proposal](https://github.com/rust-lang/cargo/issues/14903#issuecomment-2523803041) for more details.

**Expected result**

Milestones
1. An unstable feature for multiple build scripts
2. An unstable feature for passing parameters to build scripts from `Cargo.toml`, built on the above
3. An unstable feature for build script delegation, built on the above two

Bonus: preparation work to stabilize a subset of artifact dependencies.

**Project size**

Large.

**Mentor**
- Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))

### Distributed and resource-efficient verification

This project is being implemented by [Zhou Jiping](https://github.com/zjp-CN).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/5677hd6S)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Distributed.20and.20resource-efficient.20verification/with/516964679)

**Description**

We have taken a goal to
[instrument the Rust standard library with safety contracts](https://rust-lang.github.io/rust-project-goals/2025h1/std-contracts.html).
With this approach we are moving from informal comments specifying safety
requirements on `unsafe` functions to executable Rust code.
To prove that these safety requirements hold in all possible executions we need
to run static analysis tools.
We would further like to prove that these safety requirements continue to hold
despite code changes.
Therefore, we will want to run static analysis tools that prove these safety
requirements in continuous integration.
We have started such an effort in our
[verify-rust-std](https://github.com/model-checking/verify-rust-std) fork.

Static analysis tools will typically require compute effort that may go up to
minutes per function that needs to be proved.
With a growing number of contracts we will, therefore, need to distribute proof
effort across multiple nodes.
We may, however, also _reduce_ the proof effort when we can identify that any
given proof necessarily continues to hold as the transitive closure of functions
governed by the contract has not been modified since the proof last completed.

We are looking for contributions in the following areas:
1. A reachability- or impact analysis that, given a code change, determines
   which proofs require re-verification. This will avoid wasting compute
   resources for unnecessary re-verification.
2. A system that will shard proofs across multiple nodes and recombine their
   results. Multiple verification tools may be involved, and tools may have
   varying performance characteristics. Load balancing could conceivably be done
   in a dynamic fashion (where communication between nodes is required, but this
   may be hard to accomplish with GitHub runners), or per a pre-computed
   distribution (mapping pre-defined sets of verification tasks to runners). In
   the latter (and likely more feasible) scenario the distribution should be
   easy to adjust via configuration files for we expect the set of verification
   tasks to change over time.

**Expected result**

A system that can reliably run all verification tasks within a time limit (where
that time limit needs to be determined empirically), and for changes that do not
impact any contract no actual verification tool is invoked.

**Project size**

Medium.

**Mentor**
- Michael Tautschnig ([GitHub](https://github.com/tautschnig), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/887765-Michael-Tautschnig))

### Enable Witness Generation in `cargo-semver-checks`

This project is being implemented by [Talyn Veugelers](https://github.com/GlitchlessCode).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/MMRSG9WU)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Enable.20Witness.20Generation.20in.20cargo-semver-checks/with/516964780)

**Description**

When `cargo-semver-checks` reports a breaking change, it in principle has seen enough information for the breakage to be reproduced with an example program: a *witness* program.
Witness programs are valuable as they confirm that the suspected breakage did indeed happen, and is not a false-positive.

**Expected result**

Automatic witness generation is something we've explored, but we've only scratched the surface at implementing it so far.
The goal of this project would be to take it the rest of the way: enable `cargo-semver-checks` to (with the user's opt-in) generate witness programs for each lint, verify that they indeed demonstrate the detected breakage, and inform the user appropriately of the breakage and the manner in which it was confirmed.
If a witness program *fails* to reproduce breakage flagged by one of our lints, we've found a bug — the tool should then prepare a diagnostic info packet and offer to help the user open an auto-populated GitHub issue.

**Stretch goal:** having implemented witness generation, run another study of SemVer compliance in the Rust ecosystem, similar to [the study we completed in 2023](https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/). The new study would cover many more kinds of breaking changes, since `cargo-semver-checks` today has 2.5x times more lints than it did back then. It would also reveal any new false-positive issues, crashes, or other regressions that may have snuck into the tool in the intervening years.

**Project size**

Large.

**Mentor**
- Predrag Gruevski ([GitHub](https://github.com/obi1kenobi/), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/474284-Predrag-Gruevski-(he-him)))

**Related Links**
- [Playground where you can try querying Rust data](https://play.predr.ag/rustdoc)
- [Use of witness programs to verify breaking change lints](https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#automated-validation-via-witnesses)

### Extend behavioural testing of `std::arch` intrinsics

This project is being implemented by [Madhav Madhusoodanan](https://github.com/madhav-madhusoodanan).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/DeMQAjwi)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Extend.20behavioural.20testing.20of.20std.3A.3Aarch.20intrinsics/with/516964868)

**Description**

The [`std::arch`](https://doc.rust-lang.org/nightly/std/arch/index.html) module in the standard library provides architecture-specific intrinsic functions, which typically directly map to a single machine instruction.

These intrinsics are based on the architecture-specific intrinsics in C, which are usually based on a vendor specification and then implemented by C compilers such as Clang or GCC.

Rust supports thousands of intrinsics and we need to verify that they match the behavior of the equivalent intrinsics in C. A first step towards this has been the [`intrinsic-test`](https://github.com/rust-lang/stdarch/tree/master/crates/intrinsic-test) which fuzz tests the ARM (AArch32 and AArch64) intrinsics by generating C and Rust programs which call the intrinsics with random data and then verifying that the output is the same in both programs.

While this covers the ARM architectures, we have thousands of intrinsics for other architectures (notably x86) which are only lightly tested with manual tests. The goal of this project is to extend `intrinsic-test` to other architectures: x86, PowerPC, LoongArch, etc.

**Expected result**

By the end of this project `intrinsic-test` should be able to validate the behavior of intrinsics on multiple architectures. The primary goal is to support x86 since this is the most widely used architecture, but stretch goals could include support for other architectures such as PowerPC, LoongArch, WebAssembly, etc.

**Project size**

Medium.

**Mentors**
- Amanieu d'Antras ([GitHub](https://github.com/Amanieu), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/143274-Amanieu-d'Antras))

**Related links**
- [t-libs/stdarch](https://rust-lang.zulipchat.com/#narrow/channel/208962-t-libs.2Fstdarch)

### Implement merge functionality in bors

This project is being implemented by [Sakibul Islam](https://github.com/Sakib25800).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/HlR12jqX)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Implement.20merge.20functionality.20in.20bors/with/516964988)

**Description**

Various Rust repositories under the [rust-lang](https://github.com/rust-lang) organization use a merge queue bot (bors) for testing and merging pull requests. Currently, we use a legacy implementation called [homu](https://github.com/rust-lang/homu), which is quite buggy and very difficult to maintain, so we would like to get rid of it. We have started the implementation of a new bot called simply [bors](https://github.com/rust-lang/bors), which should eventually become the primary method for merging pull requests in the [rust-lang/rust](https://github.com/rust-lang/rust) repository.

The bors bot is a GitHub app that responds to user commands and performs various operations on a GitHub repository. Primarily, it creates merge commits and reports test workflow results for them. It can currently perform so-called "try builds", which can be started manually by users on a given PR to check if a subset of CI passed on the PR. However, the most important functionality, actually merging pull requests into the main branch, has not been implemented yet.

**Expected result**

bors can be used to perform pull request merges, including "rollups". In an ideal case, bors will be already usable on the `rust-lang/rust` repository.

**Project size**

Medium.

**Mentor**
- Jakub Beránek ([GitHub](https://github.com/kobzol), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/266526-Jakub-Ber%C3%A1nek))

**Related links**
- [Infra team](https://rust-lang.zulipchat.com/#narrow/stream/242791-t-infra)

### Improve bootstrap

This project is being implemented by [Shourya Sharma](https://github.com/Shourya742).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/2KNHAlKz)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Improve.20bootstrap/with/516965103)

**Description**

The Rust compiler it bootstrapped using a complex set of scripts and programs generally called just `bootstrap`.
This tooling is constantly changing, and it has accrued a lot of technical debt. It could be improved in many areas, for example:

- Design a new testing infrastructure and write more tests.
- Write documentation.
- Remove unnecessary hacks.

**Expected result**

The `bootstrap` tooling will have less technical debt, more tests, and better documentation.

**Project size**

Medium.

**Mentors**
- Jakub Beránek ([GitHub](https://github.com/kobzol), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/266526-Jakub-Ber%C3%A1nek))
- Jieyou Xu ([GitHub](https://github.com/jieyouxu), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/259697-Jieyou-Xu))
- Onur Özkan ([GitHub](https://github.com/onur-ozkan), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/461362-Onur-(onur-ozkan)))

**Related links**
- [Bootstrap team](https://rust-lang.zulipchat.com/#narrow/stream/326414-t-infra.2Fbootstrap)

### Improve Wild linker test suites

This project is being implemented by [Kei Akiyama](https://github.com/lapla-cogito).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/ps99Kaqk)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Improve.20Wild.20linker.20test.20suites/with/516965324)

**Description**

The Wild linker is a project to build a very fast linker in Rust that has incremental linking and
hot reload capabilities.

It currently works well enough to link itself, the Rust compiler, clang (provided you use the right
compiler flags) and a few other things. However, there are various features and combinations of
flags that don’t yet work correctly. Furthermore, we have a pretty incomplete picture of what we
don’t support.

The proposed project is to run the test suite of other linkers with Wild as the linker being tested,
then for each failure, determine what the problem is. It’s expected that many failures will have the
same root cause.

**Expected result**

Write a program, ideally in Rust, that runs the test suite of some other linker. Mold’s test suite
is pretty easy to run with Wild, so that’s probably a good default choice. The Rust program should
emit a CSV file with one row per test, whether the test passes or fails and if it fails, an attempt
to identify the cause based on errors / warnings emitted by Wild.

For tests where Wild doesn’t currently emit any error or warning that is related to the cause of the
test failure, attempt to make it do so. Some of the tests might fail for reasons that are hard to
identify. It’s OK to just leave these as uncategorised. Where tests fail due to bugs or differences
in behaviour of Wild, automatic classification likely isn’t practical. A one-off classification of
these would be beneficial.

If time permits, pick something achievable that seems like an important feature / bug to support /
fix and implement / fix it.

**Project size**

Medium.

**Mentor**
- David Lattimore ([GitHub](https://github.com/davidlattimore), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/198560-David-Lattimore))

**Related links**
- [Wild linker](https://github.com/davidlattimore/wild)
- [Blog posts, most of which are about Wild](https://davidlattimore.github.io/)

### Improving the Rustc Parallel Frontend: Parallel Macro Expansion

This project is being implemented by [Lorrens](https://github.com/LorrensP-2158466).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/SBW3GMno)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Improve.20Parallel.20Frontend.20Parallel.20Macro.20expansion/with/516965603)

**Description**

Improving compiler performance has always been a focus of the Rust community and one of the main tasks of the compiler team. [Parallelization](https://rustc-dev-guide.rust-lang.org/parallel-rustc.html) of rust compiler is an important and effective approach.
Currently, the backend end (codegen part) of the compiler has been parallelized, which has brought a huge improvement in the performance of the compiler. However, there is still much room for improvement in the parallelization of the rust frontend.

The most important and valuable work in this area are two aspects:

A) Diagnosing and fixing deadlock [issues](https://github.com/rust-lang/rust/issues?q=is%3Aopen+label%3AWG-compiler-parallel+deadlock) caused by the execution order of compiler queries in a multithreaded environment.
[Queries](https://rustc-dev-guide.rust-lang.org/query.html) is a unique design of the Rust compiler, which is used to achieve incremental compilation process. It divides the compiler
process into various parts and caches the execution results of each part. However, queries caching dependencies between multiple threads may cause deadlock.
[`Work-stealing`](https://en.wikipedia.org/wiki/Work_stealing), a method used to improve parallelization performance, is the core reason.

To solve these problems, we need to find the part of the compiler process that causes deadlock through diagnosing coredumps in issues, and adjusting the execution order
of this part of code so that there will be no circular dependencies on the query caches between multiple threads. This [PR](https://github.com/rust-lang/rust/pull/118488) is a good example of solving a deadlock problem.

B) Improving the performance of the parallel frontend
The parallel frontend has implemented parallelization in type checking, MIR borrow checking and other parts of the compiler. However, there is still a lot of room for improvement:
- HIR lowering. Modifying the array structure of `tcx.untracked.definitions` so that it can be accessed efficiently in multiple threads is likely to be the key.
- Macro expansion. How to deal with the order problem of name resolution during macro expansion is a difficult problem.
- Lexing and/or parsing.

Achieving the above goals is of big significance to improving the performance of the Rust compiler.

The project could choose either one of these two areas, or try to tackle both of them together.

**Expected result**

Parallel frontend will not cause deadlock issues. We can ensure usability through [UI testing](https://github.com/rust-lang/rust/pull/132051).

The performance of the compiler will be improved, ideally at least by a couple of percentage points.

**Project size**

Medium.

**Mentor**
- Sparrow Li ([GitHub](https://github.com/SparrowLii), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/353056-Sparrow-Li))

**Related links**
- [Parallel frontend working group](https://rust-lang.zulipchat.com/#narrow/channel/187679-t-compiler.2Fwg-parallel-rustc)
- [Parallel frontend project goal](https://rust-lang.github.io/rust-project-goals/2025h1/parallel-front-end.html)

### Make `cargo-semver-checks` faster

This project is being implemented by [JosephC](https://github.com/CLIDragon).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/qs2rDLG4)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Make.20cargo-semver-checks.20faster/with/516965733)

**Description**

As more lints get added to [`cargo-semver-checks`](https://github.com/obi1kenobi/cargo-semver-checks), its runtime grows longer.
As a result, users' iteration loops and CI pipelines take longer as well, degrading the overall experience of using the tool.

Figure out ways to speed up `cargo-semver-checks`, and find good ways to deploy them without degrading the maintainability of the codebase!

**Expected result**

The wall-clock runtime of running `cargo-semver-checks` on a large Rust crate gets cut by 50-80%, while still running the same lints as before.

**Project size**

Large.

**Mentor**
- Predrag Gruevski ([GitHub](https://github.com/obi1kenobi/), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/474284-Predrag-Gruevski-(he-him)))

**Related Links**
- [Playground where you can try querying Rust data](https://play.predr.ag/rustdoc)
- [Past optimization work: Speeding up Rust semver-checking by over 2000x](https://predr.ag/blog/speeding-up-rust-semver-checking-by-over-2000x/)
- [Conference talk: How Database Tricks Sped up Rust Linting Over 2000x](https://www.youtube.com/watch?v=Fqo8r4bInsk)
- [Query engine adapter, where many of the optimizations may be deployed](https://github.com/obi1kenobi/trustfall-rustdoc-adapter)

### Make Rustup Concurrent

This project is being implemented by [Francisco Gouveia](https://github.com/FranciscoTGouveia).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/CpXV4kzH)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Make.20Rustup.20Concurrent/with/516965858)

**Description**

[rustup](https://github.com/rust-lang/rustup) is an indispensable part of Rust's infrastructure, as it provides easy access to a Rust toolchain to millions of Rust users.

When installing a toolchain, it first downloads a set of components and then extracts them to disk. Currently, all downloads and disk I/O is performed serially, which makes rustup slower than it could be. Ideally, it should be able to overlap network downloads with disk I/O, and potentially also perform multiple network downloads at once.

Making rustup faster could have a high impact on the Rust ecosystem, particularly in CI environments, where rustup is typically used to download a Rust toolchain in every workflow execution. Since there are tens of thousands of repositories that use Rust in their CI, this can add up quickly.

There has been a prior [experiment](https://github.com/dtolnay/fast-rustup) that showed that concurrent rustup could in fact provide non-trivial performance improvements. [This issue](https://github.com/rust-lang/rustup/issues/731) contains discussion on the topic.

The rustup codebase now uses `async`, which should make implementing concurrent network and disk operations simpler.

The goal of the project is to add concurrency to rustup to enable overlap od network and disk I/O operations and perform benchmarks and experiments to evaluate what is the performance effect of such a change and when it is even worth it to perform it.

**Expected result**

Rustup will be able to overlap network and disk I/O and perform network requests concurrently.

**Project size**

Medium.

**Mentor**
- rami3l ([GitHub](https://github.com/rami3l), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/616990-rami3l))

**Related Links**
- [Rustup discord channel](https://discord.com/channels/442252698964721669/463480252723888159)
- [fast-rustup experiment](https://github.com/dtolnay/fast-rustup)
- [Concurrent rustup GitHub issue](https://github.com/rust-lang/rustup/issues/731)

### Mapping the Maze of Rust's UI Test Suite with Established Continuous Integration Practices

This project is being implemented by [Julien Robert](https://github.com/oneirical).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/KP02lKL4)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Mapping.20the.20Maze.20of.20Rust's.20UI.20Test.20Suite/with/516965989)

**Description**

The Rust compiler (`rustc`) relies on large suites of integration tests to check its behavior. One of such test suite is the `ui` test suite (see [tests/ui]). The `ui` test suite has more than 18000 tests, and continues to grow, so it's important that it has a good organization and usability so contributors can find a test (at all) or identify possible test coverage for some feature/behavior.

However, there's a lot of tests in the `ui` test suite that suffer from suboptimal organization, naming and other kinds of deficiencies that make certain `ui` tests less effective than they could be. See [Tracking Issue for ui test suite improvements #133895][ui-tracking-issue] for common issues and potential improvement ideas. The goal of this project is to improve the `ui` test suite's organization and usability.

The major challenge of this project is to identify how to *improve* certain `ui` tests *without regressing test intent*.

**Expected result**

Improved `ui` test suite organization and/or usability. Possible outcomes include but are not limited to:

- Fewer top-level tests immediately under (`tests/ui/`), to be moved under more fitting subdirectories.
- Some `ui` tests have improved test docs regarding test intention / references.
- Some `ui` tests are adjusted to better serve their actual test intent.

See the [tracking issue][ui-tracking-issue] for more detailed descriptions of what more effective `ui` tests *could* look like.

**Project size**

Large.

**Mentor**
- Jieyou Xu ([GitHub](https://github.com/jieyouxu), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/259697-Jieyou-Xu))

[tests/ui]: https://github.com/rust-lang/rust/tree/master/tests/ui
[ui-tracking-issue]: https://github.com/rust-lang/rust/issues/133895

### Modernising the libc Crate

This project is being implemented by [Abdul Muiz](https://github.com/mbyx).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/r3LkZkOy)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Modernising.20the.20libc.20Crate/with/516966121)

**Description**

The [libc](https://github.com/rust-lang/libc) crate is one of the oldest crates of the Rust ecosystem, long predating
Rust 1.0. Additionally, it is one of the most widely used crates in the ecosystem (#4 most downloaded on crates.io).
This combinations means that the current version of the libc crate (`v0.2`) is very conservative with breaking changes
has accumulated a list of things to do in a 1.0 release. Additionally, some of the infrastructure for `lib` is rather
outdated.

Most of the changes required for 1.0 are under the [1.0 milestone](https://github.com/rust-lang/libc/milestone/1). Some
of these come from the evolution of the underlying platforms, some come from a desire to use newer language features,
while others are simple mistakes that we cannot correct without breaking existing code.

The crate used for testing `libc` (`ctest`) uses an old syntax parser that cannot support modern Rust, so some of the
changes will require rewriting `ctest` to use a newer parser (e.g. `syn`). This upgrade is tracked at
https://github.com/rust-lang/libc/issues/4289.

The goal of this project is to prepare and release the next major version of the libc crate.

**Expected result**

The libc crate is cleaned up and modernized, and released as version 0.3.

**Project size**

Medium.

**Mentor**
- Trevor Gross ([GitHub](https://github.com/tgross35), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/532317-Trevor-Gross))

**Related links**
- [Library team](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs)

### New proc-macro Server API for Rust-Analyzer

This project is being implemented by [Neil Wang](https://github.com/DriedYellowPeach).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/76ekEjd1)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20New.20proc-macro.20Server.20API.20for.20Rust-Analyzer/with/516966300)

**Description**

Today, rust-analyzer (and RustRover) expands proc-macros by spawning a separate proc-macro server
process that loads and executes the proc-macro dynamic libraries. They communicate to this process
via a JSON RPC interface that has not been given much thought when it was implemented, now starting
to show its limitations.

The goal is to replace this current implementation entirely in favor of a more performant format
that also supports the more complicated needs of the proc-macro API, outlined in
https://github.com/rust-lang/rust-analyzer/issues/19205.

**Expected result**

There exists a new proc-macro server that is more efficient and allows for implementing the
remaining proc-macro API. Ideally, it should be integrated within rust-analyzer.

**Project size**

Medium.

**Mentor**
- Lukas Wirth ([GitHub](https://github.com/veykril), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/300586-Lukas-Wirth))

**Related links**
- [rust-analyzer team](https://rust-lang.zulipchat.com/#narrow/channel/185405-t-compiler.2Frust-analyzer)

### Prepare `stable_mir` crate for publishing

This project is being implemented by [Makai](https://github.com/makai410).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/3y9x5X8O)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Prepare.20stable_mir.20crate.20for.20publishing/with/516966374)

**Description**

We are advancing the Rust compiler's StableMIR API, which provides a robust foundation for code analysis tool development.
This API was specifically designed to shield developers from compiler internals, provide an intuitive interface, and to follow semantic versioning.

The project currently spans two key crates:
1. `stable_mir`: The public-facing API for tool developers
2. `rustc_smir`: The internal bridge between `stable_mir` and the Rust compiler.

As we prepare to [publish the `stable_mir` crate](https://rust-lang.github.io/rust-project-goals/2025h1/stable-mir.html), we are seeking contributions in these critical areas:

1. Refactor the dependency between `rustc_smir` and the `stable_mir` crates in the compiler to help us prepare for releasing `stable_mir` v0.1. More details of this refactoring can be found [here](https://hackmd.io/jBRkZLqAQL2EVgwIIeNMHg).
2. Implement a build time check on `stable-mir` crate to warn users that are using an unsupported version of the compiler.
3. Improve test coverage and automation including CI improvements to test with different compiler versions.
4. Create comprehensive developer documentation that covers maintenance procedures for both crates, ensuring future maintainers have clear guidelines for updates and compatibility management.
5. Continue the StableMIR integration with MiniRust to help us assess and improve StableMIR as described in [this issue](https://github.com/rust-lang/project-stable-mir/issues/66).

**Expected result**

We are able to publish an initial version of the `stable_mir` crate that works across multiple nightly versions, and that gracefully fails if the version is not supported.

**Project size**

Large.

**Mentor**
- Celina Val ([GitHub](https://github.com/celinval), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/442621-celinval))

**Related links**
- [stable_mir](https://rust-lang.zulipchat.com/#narrow/channel/320896-project-stable-mir)

### Prototype an alternative architecture for `cargo fix` using `cargo check`

This project is being implemented by [Glen Thalakottur](https://github.com/Pyr0de).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/fBOCR2Sp)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Prototype.20an.20alternative.20architecture.20for.20cargo.20fix/with/516966558)

**Description**

Some compiler errors know how to fix the problem and `cargo fix` is the command for applying those fixes.
Currently, `cargo fix` calls into the APIs that implement `cargo check` with
`cargo` in a way that allows getting the json messages from rustc and apply
them to workspace members.
To avoid problems with conflicting or redundant fixes, `cargo fix` runs `rustc` for workspace members in serial.
As one fix might lead to another, `cargo fix` runs `rustc` for each workspace member in a loop until a fixed point is reached.
This can be very slow for large workspaces.

We want to explore an alternative architecture where `cargo fix` runs the
`cargo check` command in a loop,
processing the json messages,
until a fixed point is reached.

Benefits
- Always runs in parallel
- May make it easier to extend the behavior, like with an interactive mode

Downsides
- Might have issues with files owned by multiple packages or even multiple build targets

This can leverage existing CLI and crate APIs of Cargo and can be developed as a third-party command.

See [cargo#13214](https://github.com/rust-lang/cargo/issues/13214) for more details.

**Expected result**

- A third-party command as described above
- A comparison of performance across representative crates
- An analysis of corner the behavior with the described corner cases

**Project size**

Medium.

**Mentor**
- Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))

**Related links**
- [Cargo team](https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo)

### Prototype Cargo Plumbing Commands

This project is being implemented by [Vito Secona](https://github.com/secona).

- [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2025/projects/fTDzc0sk)
- [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Prototype.20Cargo.20Plumbing.20Commands/with/516966661)

**Description**

Cargo is a high-level, opinionated command.
Instead of trying to directly support every use case,
we want to explore exposing the building blocks of the high-level commands as
"plumbing" commands that people can use programmatically to compose together to
create custom Cargo behavior.

This can be prototyped outside of the Cargo code base, using the Cargo API.

See the [Project Goal](https://rust-lang.github.io/rust-project-goals/2025h1/cargo-plumbing.html) for more details.

**Expected result**

Ideal: a performant `cargo porcelain check` command that calls out to
individual `cargo plumbing <name>` commands to implement its functionality.

Depending on the size the participant takes on and their experience,
this may be out of reach.
The priorities are:
1. A shell of `cargo porcelain check`
2. Individual commands until `cargo porcelain check` is functional
3. Performance

**Project size**

Medium.

**Mentor**
- Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))

**Related links**
- [Cargo team](https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo)
